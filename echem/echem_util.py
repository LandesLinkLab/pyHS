import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
from typing import List, Dict, Tuple, Optional, Any

def parse_chi_file(chi_path: str) -> Dict[str, Any]:
    """
    Parse CHI potentiostat text file to extract experimental parameters and data
    
    This function reads .txt files generated by CHI potentiostat software and
    extracts both header information (technique type, parameters) and
    time-series data (time, potential, current, charge).
    
    Parameters:
    -----------
    chi_path : str
        Path to CHI .txt file
    
    Returns:
    --------
    Dict[str, Any]
        Dictionary containing:
        - 'technique': str - 'CV', 'CA', or 'CC'
        - 'parameters': dict - technique-specific parameters
        - 'data': np.ndarray - (N, 4) array of [time, potential, current, charge]
        - 'headers': list - original header lines for reference
    """
    
    with open(chi_path, 'r') as f:
        lines = f.readlines()
    
    # Parse header information
    headers = []
    data_start_idx = None
    
    for i, line in enumerate(lines):
        if line.strip().startswith('#') or not line.strip():
            continue
        # Look for data section (typically starts with numeric values)
        try:
            float(line.split()[0])
            data_start_idx = i
            break
        except (ValueError, IndexError):
            headers.append(line.strip())
    
    # Determine technique type from headers
    technique = None
    if any('Cyclic' in h for h in headers):
        technique = 'CV'
    elif any('coulometry' in h.lower() for h in headers):
        technique = 'CA'  # Chronocoulometry
    elif any('amp' in h.lower() for h in headers):
        technique = 'CA'  # Chronoamperometry
    else:
        technique = 'Unknown'
    
    # Extract parameters from headers
    params = {}
    for header in headers:
        if '=' in header:
            try:
                key_val = header.split('=')
                key = key_val[0].strip()
                val = key_val[1].strip()
                
                # Try to convert to float
                try:
                    params[key] = float(val)
                except ValueError:
                    params[key] = val
            except:
                continue
    
    # Load numerical data
    try:
        # Data typically has columns: [time, potential, current, charge]
        data = np.loadtxt(chi_path, skiprows=data_start_idx, delimiter='\t')
        
        # Ensure 2D array
        if data.ndim == 1:
            data = data.reshape(1, -1)
            
    except Exception as e:
        print(f"[warning] Could not parse data from {chi_path}: {e}")
        data = np.array([])
    
    return {
        'technique': technique,
        'parameters': params,
        'data': data,
        'headers': headers
    }


def find_cv_turning_points(voltage: np.ndarray, 
                          scan_direction: str = 'positive',
                          threshold_factor: float = 0.2) -> List[int]:
    """
    Identify turning points in cyclic voltammetry data
    
    This function detects when the voltage scan direction reverses,
    which defines the boundaries of CV half-cycles.
    
    Parameters:
    -----------
    voltage : np.ndarray
        Voltage array from CV experiment
    scan_direction : str
        Initial scan direction ('positive' or 'negative')
    threshold_factor : float
        Sensitivity for detecting turning points (0.2 = 20% of max change)
    
    Returns:
    --------
    List[int]
        Indices of turning points in the voltage array
    """
    
    # Calculate second derivative to find inflection points
    if len(voltage) < 3:
        return [0]
    
    vd2 = np.diff(voltage, n=2)
    
    # Find peaks in second derivative
    if scan_direction == 'negative':
        # Look for positive peaks (change from negative to positive scan)
        peaks = np.where(vd2 > threshold_factor * vd2.max())[0] + 1
    else:
        # Look for positive peaks (change from positive to negative scan)
        peaks = np.where(vd2 > threshold_factor * vd2.max())[0] + 1
    
    # Add starting point
    turning_points = [0] + list(peaks)
    
    # Remove consecutive duplicates
    filtered_points = []
    for i in range(len(turning_points) - 1):
        if turning_points[i+1] - turning_points[i] > 1:
            filtered_points.append(turning_points[i+1])
    
    return [0] + filtered_points


def match_spectra_to_voltage(spec_times: np.ndarray,
                             chi_times: np.ndarray,
                             chi_voltages: np.ndarray) -> np.ndarray:
    """
    Match spectral acquisition times to potentiostat voltage values
    
    Since spectral measurements and potentiostat data are acquired
    independently, this function synchronizes them by finding the
    nearest voltage value for each spectrum time point.
    
    Parameters:
    -----------
    spec_times : np.ndarray
        Time stamps when spectra were acquired
    chi_times : np.ndarray
        Time stamps from potentiostat
    chi_voltages : np.ndarray
        Voltage values from potentiostat
    
    Returns:
    --------
    np.ndarray
        Voltage values corresponding to each spectrum time
    """
    
    from scipy.spatial import KDTree
    
    # Create KDTree for fast nearest neighbor search
    tree = KDTree(chi_times.reshape(-1, 1))
    
    # Find nearest potentiostat time for each spectrum time
    distances, indices = tree.query(spec_times.reshape(-1, 1))
    
    # Return corresponding voltages
    return chi_voltages[indices]


def compute_ocp_baseline(voltage: np.ndarray,
                        params: List[Dict[str, float]],
                        ocp_value: float,
                        param_key: str) -> Tuple[int, np.ndarray]:
    """
    Find baseline values at open circuit potential (OCP)
    
    This function identifies the spectrum closest to OCP and uses it
    as a reference for calculating changes in spectral parameters.
    
    Parameters:
    -----------
    voltage : np.ndarray
        Voltage array for one CV cycle
    params : List[Dict[str, float]]
        List of fitted parameters for each spectrum
    ocp_value : float
        Open circuit potential value
    param_key : str
        Parameter key to extract baseline (e.g., 'peakeV1', 'FWHMeV1')
    
    Returns:
    --------
    Tuple[int, np.ndarray]
        - Index of OCP point
        - Array of parameter values relative to OCP baseline
    """
    
    # Find point closest to OCP (search first half of cycle)
    half_cycle = len(voltage) // 2
    ocp_distances = np.abs(voltage[:half_cycle] - ocp_value)
    ocp_idx = np.argmin(ocp_distances)
    
    # Extract parameter values
    param_values = np.array([p.get(param_key, 0) for p in params])
    
    # Calculate relative change from OCP baseline
    baseline_value = param_values[ocp_idx]
    delta_params = param_values - baseline_value
    
    return ocp_idx, delta_params


def plot_echem_overview(spec_times: np.ndarray,
                       voltages: np.ndarray,
                       spectra: np.ndarray,
                       wavelengths: np.ndarray,
                       params: List[Dict[str, float]],
                       output_path: Path,
                       sample_name: str) -> None:
    """
    Create overview plot showing spectral evolution during electrochemical experiment
    
    This function generates a multi-panel figure showing:
    - Applied voltage vs time
    - Spectral intensity heatmap
    - Resonance energy vs time
    - FWHM vs time
    - Intensity change vs time
    
    Parameters:
    -----------
    spec_times : np.ndarray
        Spectrum acquisition times
    voltages : np.ndarray
        Applied voltages at each spectrum time
    spectra : np.ndarray
        2D array of spectra (Time × λ)
    wavelengths : np.ndarray
        Wavelength array
    params : List[Dict[str, float]]
        Fitted parameters for each spectrum
    output_path : Path
        Path to save the figure
    sample_name : str
        Sample name for plot title
    """
    
    fig, axes = plt.subplots(5, 1, figsize=(10, 12), sharex=True)
    
    # Convert wavelengths to energy for better visualization
    energy = 1239.842 / wavelengths
    
    # Panel 1: Spectral heatmap
    im = axes[0].imshow(spectra.T, aspect='auto', cmap='hot',
                       extent=[spec_times.min(), spec_times.max(),
                              wavelengths.min(), wavelengths.max()],
                       origin='lower')
    axes[0].set_ylabel('Wavelength (nm)', fontsize=12, fontweight='bold')
    axes[0].set_title(f'{sample_name} - EChem Spectroscopy', fontsize=14)
    plt.colorbar(im, ax=axes[0], label='Intensity (a.u.)')
    
    # Panel 2: Resonance energy
    peak_energies = [p.get('peakeV1', np.nan) for p in params]
    axes[1].scatter(spec_times, peak_energies, c='red', s=20, marker='d')
    axes[1].set_ylabel('Resonance (eV)', fontsize=12, fontweight='bold')
    axes[1].grid(True, alpha=0.3)
    
    # Panel 3: FWHM
    fwhms = [p.get('FWHMeV1', np.nan) for p in params]
    axes[2].scatter(spec_times, fwhms, c='red', s=15, marker='d')
    axes[2].set_ylabel('FWHM (eV)', fontsize=12, fontweight='bold')
    axes[2].grid(True, alpha=0.3)
    
    # Panel 4: Intensity change (if baseline available)
    if len(params) > 0 and 'area1' in params[0]:
        baseline_area = params[0]['area1']
        intensity_changes = [(p.get('area1', baseline_area) - baseline_area) / baseline_area * 100 
                            for p in params]
        axes[3].scatter(spec_times, intensity_changes, c='red', s=20, marker='d')
    axes[3].set_ylabel('Intensity change (%)', fontsize=12, fontweight='bold')
    axes[3].grid(True, alpha=0.3)
    
    # Panel 5: Applied voltage
    axes[4].plot(spec_times, voltages, 'r-', linewidth=1.5)
    axes[4].set_ylabel('E (V)', fontsize=12, fontweight='bold')
    axes[4].set_xlabel('Elapsed Time (s)', fontsize=12, fontweight='bold')
    axes[4].grid(True, alpha=0.3)
    
    # Formatting
    for ax in axes:
        ax.tick_params(axis='both', which='major', labelsize=10)
    
    plt.tight_layout()
    fig.savefig(output_path, dpi=300, bbox_inches='tight')
    plt.close(fig)
    
    print(f"[info] Saved EChem overview plot: {output_path}")


def save_echem_cycle_data(cycles: List[Dict[str, Any]],
                          output_dir: Path,
                          sample_name: str) -> None:
    """
    Save cycle-averaged data to text files
    
    Parameters:
    -----------
    cycles : List[Dict[str, Any]]
        List of cycle dictionaries containing averaged parameters
    output_dir : Path
        Directory to save output files
    sample_name : str
        Sample name for file naming
    """
    
    output_dir.mkdir(parents=True, exist_ok=True)
    
    for i, cycle in enumerate(cycles):
        cycle_num = i + 1
        
        # Prepare data array
        voltage = cycle['voltage_avg']
        n_points = len(voltage)
        
        # Collect all parameters
        data_dict = {
            'Voltage(V)': voltage,
            'PeakEnergy(eV)': cycle.get('peak_avg', np.zeros(n_points)),
            'PeakEnergy_SE(eV)': cycle.get('peak_se', np.zeros(n_points)),
            'FWHM(eV)': cycle.get('fwhm_avg', np.zeros(n_points)),
            'FWHM_SE(eV)': cycle.get('fwhm_se', np.zeros(n_points)),
            'DeltaPeak(meV)': cycle.get('delta_peak_avg', np.zeros(n_points)) * 1000,
            'DeltaFWHM(meV)': cycle.get('delta_fwhm_avg', np.zeros(n_points)) * 1000,
            'IntensityChange(%)': cycle.get('delta_intensity_avg', np.zeros(n_points))
        }
        
        # Create header
        header = '\t'.join(data_dict.keys())
        
        # Stack data
        data_array = np.column_stack([data_dict[k] for k in data_dict.keys()])
        
        # Save to file
        output_file = output_dir / f"{sample_name}_cycle_{cycle_num:02d}.txt"
        np.savetxt(output_file, data_array, delimiter='\t', header=header, 
                  comments='', fmt='%.6f')
        
    print(f"[info] Saved {len(cycles)} cycle data files to {output_dir}")